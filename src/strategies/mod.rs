mod consensus;

use std::collections::HashMap;
use polars::prelude::*;
use crate::types::Signal;
use crate::indicators::{Indicator};
pub use crate::strategies::consensus::Consensus;


/// A [`IndicatorContainer`] is a collection of [`Indicator`] objects.
type IndicatorContainer = Vec<Box<dyn Indicator>>;

/// A [`Strategy`] is a facade for interfacing with more than one [`Indicator`] objects.
///
/// A simple interface is provided for bootstrapping historical candle data, processing new candle data,
/// and generating a consensus [`Signal`] among all [`Indicator`] objects.
pub struct Strategy {
    pub indicators: IndicatorContainer,
    consensus: Consensus,
}
impl Strategy {
    pub fn new(
        indicators: IndicatorContainer,
        consensus: Consensus
    ) -> Self {
        Self {
            indicators,
            consensus,
        }
    }

    /// Bootstrap historical candle data
    pub fn bootstrap(&mut self, data: DataFrame) {
        for indicator in self.indicators.iter_mut() {
            indicator.process_existing(&data);
        }
    }

    /// Process a new candle and generate a consensus [`Signal`] among the [`Indicator`] objects.
    ///
    /// Internally, the dataframe is propagated to all internal indicators, and the resulting
    /// signals are gathered. A consensus is then reached between the signals, and returned.
    ///
    /// # Arguments
    /// * `row` - The new candle data to process
    ///
    /// # Returns
    /// A [`Signal`] representing the consensus between all [`Indicator`] objects
    ///
    /// # Panics
    /// * If the DataFrame does not contain exactly one new row
    pub fn process(&mut self, row: &DataFrame) -> Signal {
        for indicator in self.indicators.iter_mut() {
            indicator.process_new(row);
        }

        self.get_last_signal()
    }

    /// Get the last consensus [`Signal`] generated by the [`Indicator`] objects
    pub fn get_last_signal(&self) -> Signal {
        let signals = self.indicators
            .iter()
            .map(|x| x.get_last_signal().expect("No signal found"))
            .collect::<Vec<Signal>>();

        self.consensus.reduce(signals.into_iter())
    }

    pub fn get_all_graphs(&self) -> Result<Option<HashMap<&'static str, DataFrame>>, ()> {
        if self.indicators.is_empty() {
            Ok(None)
        } else {
            let graphs = self.indicators.iter().map(|x| {
                let graph = x.get_graph().unwrap();
                (x.get_name(), graph.clone())
            }).collect::<HashMap<_, _>>();

            Ok(Some(graphs))
        }
    }

    /// Get a dataframe of all signals generated by the [`Indicator`] objects
    fn get_all_signals(&self) -> Result<Option<DataFrame>, ()> {
        if self.indicators.is_empty() {
            return Ok(None)
        } else if self.indicators.len() == 1 {
            let indicator = &self.indicators[0];
            let df = indicator.get_signals()
                .unwrap()
                .clone()
                .rename("signals", indicator.get_name())
                .unwrap()
                .to_owned();
            return Ok(Some(df))
        }

        // ensure that indices for all indicators are the same
        let indicator1 =
            self.indicators[0]
                .get_signals();
        if indicator1.is_none() {
            // TODO: state that the indicator has no signals
            return Err(())
        }
        let index1 = indicator1.unwrap().column("time").unwrap();
        for indicator in self.indicators.iter() {
            let index = indicator.get_signals().unwrap().column("time").unwrap();
            if index1 != index {
                // TODO: state that the indices are not aligned
                return Err(())
            }
        }

        // combine all signals into a single DataFrame
        let mut df = df![
            "time" => index1.clone()
        ].unwrap();

        for indicator in self.indicators.iter() {
            let signal_history = indicator.get_signals().unwrap().column("signals").unwrap().clone();
            df.replace_or_add(indicator.get_name(), signal_history).unwrap();
        }

        Ok(Some(df))
    }

    /// Get signals which are not `Hold`
    ///
    /// This method uses [`Self::get_all_signals`], then filters out rows where all signals are `Hold`.
    /// The output is intended to be used for evaluating the consensus between indicators during backtesting,
    /// or debugging.
    ///
    /// # Returns
    ///
    /// A [`DataFrame`] which contains all signal columns from [`Self::get_all_signals`], but only rows
    /// which have at least one [`Signal`] which is not [`Signal::Hold`].
    pub fn get_filtered_signals(&self) -> Result<Option<DataFrame>, ()> {
        if let Some(signals) = self.get_all_signals()? {
            // get all column names except for `time`
            let column_names = signals.get_column_names();
            let column_names = column_names.iter().filter(|x| {
                *x != &"time"
            }).collect::<Vec<&&str>>();

            println!("{:?}", column_names);

            // for all columns, get a mask of the rows which are not 0 (ie: `Hold`)
            let mut combined_mask = None;
            column_names.iter().for_each(|x| {
                let mask = signals.column(*x).unwrap().i8().unwrap().iter().map(|x| {
                    x != Some(Signal::Hold.into())
                }).collect::<BooleanChunked>();
                if combined_mask.is_none() {
                    combined_mask = Some(mask);
                } else {
                    let _mask = combined_mask.as_ref().unwrap();
                    combined_mask = Some(_mask | &mask);
                }
            });
            let filtered = signals.filter(&combined_mask.unwrap()).unwrap();
            return Ok(Some(filtered))
        }
        Ok(None)
    }

    pub fn get_combined_signals(&self) -> Result<Option<DataFrame>, ()> {
        // TODO: return dataframe with unified (ie: consensus) signal column
        todo!()
        // this can be done by summing the signal columns, and then applying the consensus
        // ie: if `unison`, and there are 3 columns, then only values of 3/-3 are valid
        // if `majority` and 3 columns, then values gt/lt 2/-2 are valid, etc, etc
    }
}
