use std::io::Error;
use std::path::Path;
use chrono::NaiveDateTime;
use polars::frame::DataFrame;
use crate::markets::{BaseMarket};
use crate::markets::manager::CandleManager;
use crate::portfolio::{Portfolio, TradeHandlers, Persistence};
use crate::strategies::Strategy;
use crate::types::{FutureTrade, Side};

/// The `Engine` is the main entry point for the trading bot.
///
/// This serves as the bridge between a [`Portfolio`], [`Strategy`], and a [`BaseMarket`] implementation.
/// The primary purpose is to orchestrate the fetching of candle data, and submit trades based on the
/// signals generated by the new candle data.
pub struct Engine<'a, T>
where T: BaseMarket {
    current_interval: String,
    trading_pair: String,

    portfolio: Portfolio,
    strategy: Strategy,
    market: &'a T,
    manager: CandleManager<'a, T>,
}

impl<'a, T> Engine<'a, T>
where T: BaseMarket {
    pub fn new(
        current_interval: &str,
        portfolio: Portfolio,
        strategy: Strategy,
        pair: &str,
        market: &'a T,
    ) -> Self {
        // TODO: do not clone market. Instead use a reference
        let manager = CandleManager::new(pair, market);
        let current_interval = current_interval.to_string();
        let trading_pair = pair.to_string();
        Self {
            current_interval,
            trading_pair,
            portfolio,
            strategy,
            market,
            manager,
        }
    }

    /// Bootstrap the engine by fetching candles and bootstrapping the indicators
    pub async fn bootstrap(&mut self) {
        // TODO: load candles
        self.manager.update_all().await;
        self.strategy.bootstrap(self.manager.get(&self.current_interval).unwrap().clone());
    }

    /// Run the engine for a single iteration
    ///
    /// This will update the candle manager, pass the new row to the strategy, and then
    /// submit a trade to the market if the strategy returns a signal.
    pub async fn run(&mut self) {
        let new_row = self.manager
            .update(&self.current_interval)
            .await
            .unwrap();
        if new_row.height() == 0 {
            eprintln!("No new data available");
            return;
        } else if new_row.height() > 1 {
            eprintln!("Multiple new rows available...");
            return;
        }

        // pass row to strategy
        let signal = self.strategy.process(&new_row);

        let side = match Side::try_from(signal) {
            Ok(side) => side,
            Err(_) => return,
        };

        // generate rate
        let rate = match side {
            Side::Buy => generate_buy_rate(&new_row),
            Side::Sell => generate_sell_rate(&new_row),
        };

        // propose a trade
        let trade = match side {
            Side::Buy => {
                if self.portfolio.able_to_buy() {
                    let amount = self.portfolio.get_buy_amount();
                    let point = NaiveDateTime::from_timestamp_millis(
                        new_row.column("time")
                            .unwrap()
                            .datetime()
                            .unwrap()
                            .get(0)
                            .unwrap()).unwrap();
                    Some(FutureTrade::new(
                        side,
                        rate,
                        amount,
                        point
                    ))
                } else {
                    None
                }
            }
            Side::Sell => {
                self.portfolio.is_rate_profitable(rate)
            }
        };

        // if a trade has been proposed, submit it to the market
        if let Some(trade) = trade {
            let executed = self.market.submit_order(trade, self.trading_pair.clone())
                .await
                .unwrap();
            self.portfolio.add_executed_trade(executed);
        }
    }

    pub fn save(&mut self, path: &Path) -> Result<(), Error> {
        self.manager.save(path)?;
        self.portfolio.save(path)?;
        Ok(())
    }
}

/// Use the current candle row to generate a rate for buying assets
///
/// This uses a weighted average of the close, high, and open prices to generate a rate.
///
/// # Arguments
/// * `row` - The current candle row
///
/// # Returns
/// `f64` - The rate to buy assets at
fn generate_buy_rate(row: &DataFrame) -> f64 {
    let close = row.column("close").unwrap().f64().unwrap().get(0).unwrap();
    let high = row.column("high").unwrap().f64().unwrap().get(0).unwrap();
    let open = row.column("open").unwrap().f64().unwrap().get(0).unwrap();

    let sum = (close * 2.0) + high + open;
    sum / 4.0
}

/// Use the current candle row to generate a rate for selling assets
///
/// This uses a weighted average of the close, low, and open prices to generate a rate.
///
/// # Arguments
/// * `row` - The current candle row
///
/// # Returns
/// `f64` - The rate to sell assets at
fn generate_sell_rate(row: &DataFrame) -> f64 {
    let close = row.column("close").unwrap().f64().unwrap().get(0).unwrap();
    let low = row.column("low").unwrap().f64().unwrap().get(0).unwrap();
    let open = row.column("open").unwrap().f64().unwrap().get(0).unwrap();

    let sum = (close * 2.0) + low + open;
    sum / 4.0
}