use crate::markets::manager::CandleManager;
use crate::markets::BaseMarket;
use crate::portfolio::{Persistence, Portfolio, TradeHandlers};
use crate::strategies::Strategy;
use crate::types::{FutureTrade, Side, Signal};
use chrono::{NaiveDateTime, Utc};
use polars::frame::DataFrame;
use std::io::Error;
use std::path::Path;

/// The `Engine` is the main entry point for the trading bot.
///
/// This serves as the bridge between a [`Portfolio`], [`Strategy`], and a [`BaseMarket`] implementation.
/// The primary purpose is to orchestrate the fetching of candle data, and submit trades based on the
/// signals generated by the new candle data.
pub struct Engine<'a, T>
where
    T: BaseMarket,
{
    current_interval: String,
    trading_pair: String,

    portfolio: Portfolio,
    strategy: Strategy,
    market: &'a T,
    manager: CandleManager<'a, T>,
}

impl<'a, T> Engine<'a, T>
where
    T: BaseMarket,
{
    pub fn new(
        current_interval: &str,
        portfolio: Portfolio,
        strategy: Strategy,
        pair: &str,
        market: &'a T,
    ) -> Self {
        // TODO: do not clone market. Instead use a reference
        let manager = CandleManager::new(pair, market);
        let current_interval = current_interval.to_string();
        let trading_pair = pair.to_string();
        Self {
            current_interval,
            trading_pair,
            portfolio,
            strategy,
            market,
            manager,
        }
    }

    /// Bootstrap indicator data from the current candle
    ///
    /// This is used to rerun bootstrapping when there has been more than one candle
    /// returned from the market, when indicators need to be updated (eg: change of parameters),
    /// or when the engine is first initialized.
    fn bootstrap(&mut self) {
        self.strategy
            .bootstrap(&self.manager.get(&self.current_interval).unwrap().clone());
    }

    /// Bootstrap the engine by fetching candles and bootstrapping the indicators
    pub async fn initialize(&mut self) {
        // TODO: load candles
        self.manager.update_all().await;
        self.bootstrap();

        // print last candle time
        let last_candle_time = self.last_candle_time();
        println!("The last candle retrieved is {last_candle_time}");

        // print feedback
        let time = Utc::now().naive_utc();
        println!("Bootstrapping was completed at {time}");
    }

    /// Fetch new candle data and process it
    ///
    /// This will fetch new candle data from the market, and then process it with the strategy.
    /// If multiple rows are returned, the engine will bootstrap the strategy and return the last
    /// row. Otherwise, a single row will be passed to `Strategy::process()`.
    ///
    /// # Returns
    /// `Option<(Signal, DataFrame)>` - A tuple containing the signal and the new candle data
    /// * `None` if there is no new candle data available
    /// * `Some((signal, row))` if there is new candle data available
    async fn fetch_candle_data(&mut self) -> Option<(Signal, DataFrame)> {
        let new_row = self.manager.update(&self.current_interval).await.unwrap();

        // get new signal. If there is no new row, return false.
        // otherwise, process single row or bootstrap
        if new_row.height() == 0 {
            return None;
        } else if new_row.height() > 1 {
            eprintln!("Got multiple rows. Bootstrapping...");
            self.bootstrap();
            let signal = self.strategy.get_last_signal();
            let last_row = self.get_last_candle();
            Some((signal, last_row))
        } else {
            let signal = self.strategy.process(&new_row);
            Some((signal, new_row))
        }
    }

    /// Run the engine for a single iteration
    ///
    /// This will update the candle manager, pass the new row to the strategy, and then
    /// submit a trade to the market if the strategy returns a signal.
    ///
    /// # Returns
    /// `bool` - Whether or not a retry should be attempted:
    /// * `true` if the engine correctly processed new candle data
    /// * `false` if there was no new candle data available. This triggers a retry.
    pub async fn run(&mut self) -> bool {
        let (signal, new_row) = match self.fetch_candle_data().await {
            Some((signal, new_row)) => (signal, new_row),
            None => return false,
        };

        // output time of last candle
        let time = NaiveDateTime::from_timestamp_millis(
            new_row
                .column("time")
                .unwrap()
                .datetime()
                .unwrap()
                .get(0)
                .unwrap(),
        )
        .unwrap();
        println!("Processed {signal} for {time}");

        // drop all hold values
        let side = match Side::try_from(signal) {
            Ok(side) => side,
            Err(_) => return true,
        };

        // generate rate
        let rate = match side {
            Side::Buy => generate_buy_rate(&new_row),
            Side::Sell => generate_sell_rate(&new_row),
        };

        // propose a trade
        let trade = match side {
            Side::Buy => {
                if self.portfolio.able_to_buy() {
                    let cost = self.portfolio.get_buy_cost();
                    let point = NaiveDateTime::from_timestamp_millis(
                        new_row
                            .column("time")
                            .unwrap()
                            .datetime()
                            .unwrap()
                            .get(0)
                            .unwrap(),
                    )
                    .unwrap();
                    Some(FutureTrade::new_from_cost(side, rate, cost, point))
                } else {
                    None
                }
            }
            Side::Sell => self.portfolio.is_rate_profitable(rate),
        };

        // if a trade has been proposed, submit it to the market
        if let Some(trade) = trade {
            let executed = self
                .market
                .submit_order(trade, self.trading_pair.clone())
                .await
                .unwrap();
            self.portfolio.add_executed_trade(executed);
        };
        true
    }

    pub fn save(&mut self, path: &Path) -> Result<(), Error> {
        self.manager.save(path)?;
        self.portfolio.save(path)?;

        println!("Saved data");
        Ok(())
    }

    /// Get the last candle time
    pub fn last_candle_time(&self) -> NaiveDateTime {
        let df = self.get_last_candle();
        let time = df
            .column("time")
            .unwrap()
            .datetime()
            .unwrap()
            .get(0)
            .unwrap();
        NaiveDateTime::from_timestamp_millis(time).unwrap()
    }

    /// Get the last candle row
    fn get_last_candle(&self) -> DataFrame {
        let df = self.manager.get(&self.current_interval).unwrap();
        df.head(Some(1))
    }
}

/// Use the current candle row to generate a rate for buying assets
///
/// This uses a weighted average of the close, high, and open prices to generate a rate.
///
/// # Arguments
/// * `row` - The current candle row
///
/// # Returns
/// `f64` - The rate to buy assets at
fn generate_buy_rate(row: &DataFrame) -> f64 {
    let close = row.column("close").unwrap().f64().unwrap().get(0).unwrap();
    let high = row.column("high").unwrap().f64().unwrap().get(0).unwrap();
    let open = row.column("open").unwrap().f64().unwrap().get(0).unwrap();

    let sum = (close * 2.0) + high + open;
    sum / 4.0
}

/// Use the current candle row to generate a rate for selling assets
///
/// This uses a weighted average of the close, low, and open prices to generate a rate.
///
/// # Arguments
/// * `row` - The current candle row
///
/// # Returns
/// `f64` - The rate to sell assets at
fn generate_sell_rate(row: &DataFrame) -> f64 {
    let close = row.column("close").unwrap().f64().unwrap().get(0).unwrap();
    let low = row.column("low").unwrap().f64().unwrap().get(0).unwrap();
    let open = row.column("open").unwrap().f64().unwrap().get(0).unwrap();

    let sum = (close * 2.0) + low + open;
    sum / 4.0
}
